<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Material Customer Manager</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Materialize CSS & icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/materialize-css@1.0.0/dist/css/materialize.min.css" rel="stylesheet">
    <style>
        html, body {
            min-height: 100vh;
            margin: 0;
            height: 100%;
            background: linear-gradient(-45deg, #fceabb 0%,#f8b500 13%,#c471f5 55%,#12c2e9 100%);
            background-size: 400% 400%;
            animation: gradientBG 15s ease-in-out infinite;
            transition: background .8s cubic-bezier(.11,.87,.51,.85), color .8s;
        }

        @keyframes gradientBG {
            0% {
                background-position: 0% 50%;
            }

            40% {
                background-position: 100% 50%;
            }

            70% {
                background-position: 100% 100%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        body.darkmode,
        html.darkmode {
            background: linear-gradient(-45deg, #191a24 0%, #142237 45%, #45117e 83%, #00695c 100%) !important;
            background-size: 400% 400% !important;
            animation: gradientBGdark 22s ease-in-out infinite !important;
            color: #e4e8f5 !important;
        }

        @keyframes gradientBGdark {
            0% {
                background-position: 72% 19%;
            }

            18% {
                background-position: 100% 70%;
            }

            45% {
                background-position: 0 100%;
            }

            66% {
                background-position: 48% 38%;
            }

            100% {
                background-position: 72% 19%;
            }
        }

        .container {
            max-width: 860px;
            margin-top: 48px;
            margin-bottom: 48px;
            border-radius: 22px;
            box-shadow: 0 10px 36px #160b2d2f, 0 1.5px 4.5px #160b2d17;
            background: rgba(255,255,255,0.97);
            padding: 38px 0px 52px 0px;
            position: relative;
            z-index: 1;
            transition: background 0.7s, background-image 0.7s;
            overflow: hidden;
            will-change: background, background-image;
        }

        .container-inner {
            padding-left: 28px;
            padding-right: 28px;
        }

        body.darkmode .container {
            background: rgba(21,24,32,0.98) !important;
            color: #e0eafd !important;
        }

        .avatar {
            display: inline-flex;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            align-items: center;
            justify-content: center;
            font-size: 1.32em;
            font-weight: bold;
            color: white;
            background: #0097a7;
            margin-right: 12px;
            box-shadow: 0 2px 12px #0001;
            letter-spacing: 1px;
        }

        .success {
            color: #43b963;
        }

        .vivid-card {
            box-shadow: 0 2px 16px #9a86fa40, 0 .5px 4px #90caf940;
            border-radius: 1.3rem;
        }

        .msg {
            margin-top: 10px;
            font-weight: bold;
            letter-spacing: 0.2px;
        }

        .center-actions > button {
            margin: 0 4px;
        }

        /* >>> NO SPACES at Tabs edges <<< */
        .tabs {
            display: flex;
            padding: 0;
            margin: 0 !important;
            border-radius: 22px 22px 0 0;
            border-bottom: 0;
            overflow: hidden;
            box-shadow: none;
            background: transparent !important;
        }

            .tabs .tab {
                flex-grow: 1;
                flex-basis: 0;
                margin: 0 !important;
                padding: 0;
                border-radius: 0;
                min-width: 0;
            }

                .tabs .tab a {
                    display: flex !important;
                    justify-content: center;
                    align-items: center;
                    width: 100% !important;
                    font-weight: 600;
                    padding: 0 13px;
                    letter-spacing: .3px;
                    box-shadow: none;
                    border-radius: 0; /* Remove corners for even flush */
                    background: rgba(255,255,255,0.98);
                    color: #294baa !important;
                    z-index: 2;
                    height: 54px; /* nice height for tabs */
                    transition: background-color .22s,color .22s,box-shadow .3s;
                    border-bottom: 3px solid transparent;
                }

                .tabs .tab:first-child a {
                    border-radius: 22px 0 0 0;
                }

                .tabs .tab:last-child a {
                    border-radius: 0 22px 0 0;
                }

                .tabs .tab a.active, .tabs .tab a:focus, .tabs .tab a:active {
                    background: #5e35b1 !important;
                    color: #fff !important;
                    box-shadow: 0 2px 13px #5e35b145;
                    border-bottom: 3px solid #ba68c8;
                }

                .tabs .tab a:hover {
                    background: linear-gradient(45deg, #6a11cb, #2575fc) !important;
                    color: #fff !important;
                    box-shadow: 0 4px 17px #6521ff33 !important;
                }

        body.darkmode .tabs .tab a {
            color: #b0d3fa !important;
            background: #231933 !important;
        }

            body.darkmode .tabs .tab a.active, body.darkmode .tabs .tab a:focus, body.darkmode .tabs .tab a:active {
                background: #7c43bd !important;
                color: #fff !important;
                border-bottom: 3px solid #40cfff;
            }

            body.darkmode .tabs .tab a:hover {
                background: linear-gradient(45deg, #8047a8, #09c9e3) !important;
                color: #fff !important;
                box-shadow: 0 4px 20px #09c9e322;
            }

        .tabs .indicator {
            display: none;
        }

        body.darkmode input, body.darkmode .card-panel, body.darkmode .modal, body.darkmode .tabs-content,
        body.darkmode .sidenav, body.darkmode .table-wrapper {
            background: #181c29 !important;
            color: #e1fafd !important;
        }

        body.darkmode table.highlight tbody tr:hover {
            background: #232a3a !important;
        }

        body.darkmode label {
            color: #a2e7ff !important;
        }

        @media (max-width: 600px) {
            .container-inner {
                padding-left: 8px;
                padding-right: 8px;
            }

            .container {
                border-radius: 12px;
            }

            .tabs {
                border-radius: 12px 12px 0 0;
            }

                .tabs .tab:first-child a {
                    border-radius: 12px 0 0 0;
                }

                .tabs .tab:last-child a {
                    border-radius: 0 12px 0 0;
                }
        }
        /* So table does not stretch box on very wide screens. */
        .table-wrapper {
            overflow-x: auto;
        }
        /* --- Animatable pattern effect --- */
        .container.patterned-bg {
            transition: background 0.45s cubic-bezier(.19,.78,.44,1.15), background-image 1s cubic-bezier(.36,.8,.3,.95);
            background-repeat: repeat !important;
            background-blend-mode: lighten,screen,normal;
            background-size: 80px 80px, 100% 100%;
            will-change: background-image, background, background-position;
            filter: saturate(1.12) brightness(1.01);
        }
    </style>
</head>
<script>
    (function () {
        // === CONFIG ===
        // expand with more pattern types if you like!
        function randomPatternCSS(mode = 'light') {
            // Pick a pattern type randomly
            let type = Math.random();
            let linecolor = mode === 'dark' ? 'rgba(255,255,255,0.07)' : 'rgba(0,0,0,0.09)';
            let accentcolor = mode === 'dark' ? 'rgba(255,255,255,0.18)' : 'rgba(0,0,0,0.17)';
            let size = Math.random() > 0.5 ? 70 : 120;
            if (type < 0.33) { // Diamonds
                return `
        repeating-linear-gradient(45deg, ${linecolor} 0 ${size / 6}px, transparent ${size / 6}px ${size / 3}px),
        repeating-linear-gradient(-45deg, ${linecolor} 0 ${size / 6}px, transparent ${size / 6}px ${size / 3}px)
      `;
            } else if (type < 0.66) { // Wavy (zigzag) lines
                return `
        repeating-linear-gradient(135deg, ${linecolor} 0 2px, transparent 2px ${size / 2}px)
      `;
            } else { // Dotted fire/random waves using conic
                return `
        repeating-conic-gradient(from 0deg, ${accentcolor} 0 15deg, transparent 15deg 30deg)
      `
            }
        }

        // --- overlay handler
        let overlay = null;
        let patternTimeout = null;

        function showOverlayPattern() {
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'fullscreen-pattern-overlay';
                overlay.style.cssText = `
        pointer-events:none; z-index:9999; position:fixed; inset:0; width:100vw; height:100vh;
        background: none;
        transition: background-image .45s cubic-bezier(.22,.83,.4,1.18);
        mix-blend-mode: multiply;
        will-change: background-image;
      `;
                document.body.appendChild(overlay);
            }
            overlay.style.backgroundImage = randomPatternCSS(
                document.body.classList.contains('darkmode') ? 'dark' : 'light'
            );
            overlay.style.display = 'block';

            // Optionally, animate pattern while mouse moves
            if (patternTimeout) clearInterval(patternTimeout);
            patternTimeout = setInterval(() => {
                overlay.style.backgroundImage = randomPatternCSS(
                    document.body.classList.contains('darkmode') ? 'dark' : 'light'
                );
            }, 900 + Math.random() * 800);
        }
        function hideOverlayPattern() {
            if (patternTimeout) clearInterval(patternTimeout);
            if (overlay) overlay.style.display = 'none';
        }

        // Show on mouseenter body but not when inside the main card
        document.body.addEventListener('mousemove', (e) => {
            // Only show if not over .container
            let el = e.target;
            let onCard = false;
            while (el) {
                if (el.classList && el.classList.contains('container')) { onCard = true; break; }
                el = el.parentElement;
            }
            if (!onCard) showOverlayPattern();
            else hideOverlayPattern();
        });
        document.body.addEventListener('mousedown', showOverlayPattern);
        document.body.addEventListener('mouseleave', hideOverlayPattern);
        document.body.addEventListener('mouseup', hideOverlayPattern);

        // Always hide when switching dark mode
        document.getElementById('darkToggle').addEventListener('change', hideOverlayPattern);

        // Optional: Hide overlay when focusing inputs (for best UX)
        document.body.addEventListener('focusin', hideOverlayPattern);

        // On initial load
        hideOverlayPattern();
    })();
</script>

<body>
    <div class="switch right" style="margin:16px 32px 0 0; position:absolute; top:0; right:0; z-index:9;">
        <label>
            <span style="vertical-align: middle;">☀️</span>
            <input type="checkbox" id="darkToggle" onclick="toggleDark()" />
            <span class="lever"></span>
            <span style="vertical-align: middle;">🌙</span>
        </label>
    </div>
    <div class="container vivid-card" id="rootContainer">
        <div class="container-inner">
            <h4 style="letter-spacing:.04em;">
                <i class="material-icons left" style="font-size:2rem;color:#8d3cff;">supervisor_account</i>
                <span style="color:#1976d2;">Customer Manager</span>
                <span class="new badge purple" data-badge-caption="Material UI"></span>
            </h4>
            <div class="row">
                <div class="col s12" style="padding:0;">
                    <ul class="tabs" id="tabsNav">
                        <li class="tab col s6"><a class="active" href="#tab1"><i class="material-icons">people</i> All Customers</a></li>
                        <li class="tab col s6"><a href="#tab2"><i class="material-icons">person_add</i> Add Customer</a></li>
                    </ul>
                </div>
                <div id="tab1" class="col s12">
                    <div class="input-field row" style="margin-bottom: 18px;">
                        <div class="col s8 m8 l10">
                            <input id="searchBox" type="text" placeholder=" " autocomplete="off" />
                            <label for="searchBox">Find customer by name</label>
                        </div>
                        <div class="col s4 m4 l2 right-align">
                            <button class="btn waves-effect blue" onclick="search()">
                                <i class="material-icons left">search</i>Search
                            </button>
                            <button class="btn waves-effect btn-flat" onclick="getAll()">
                                <i class="material-icons">refresh</i>
                            </button>
                        </div>
                    </div>
                    <div id="msg" class="msg"></div>
                    <div class="table-wrapper" id="tableWrap">
                        <table id="resultTable" class="highlight responsive-table" style="display:none;">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Name</th>
                                    <th>Mobile</th>
                                    <th>Created At</th>
                                    <th class="center-align">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="resultBody"></tbody>
                        </table>
                    </div>
                    <div id="loading" class="center-align" style="display:none;margin-top:10px;">
                        <div class="preloader-wrapper active">
                            <div class="spinner-layer spinner-blue">
                                <div class="circle-clipper left"><div class="circle"></div></div>
                                <div class="gap-patch"><div class="circle"></div></div>
                                <div class="circle-clipper right"><div class="circle"></div></div>
                            </div>
                        </div><div>Loading...</div>
                    </div>
                </div>
                <div id="tab2" class="col s12">
                    <div class="card-panel blue lighten-5 z-depth-1" style="margin-top:18px;">
                        <form id="addForm" class="row" onsubmit="addCustomer(); return false;">
                            <div class="input-field col s5">
                                <input id="inputName" type="text" maxlength="100" required autocomplete="off" />
                                <label for="inputName">Name</label>
                            </div>
                            <div class="input-field col s5">
                                <input id="inputMobile" type="tel" maxlength="10" pattern="[0-9]+" required autocomplete="off" />
                                <label for="inputMobile">Mobile (digits only)</label>
                            </div>
                            <div class="input-field col s2">
                                <button type="submit" class="btn waves-effect green" style="width: 100%;">
                                    <i class="material-icons left">add</i>Add
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Materialize JS -->
    <script src="https://cdn.jsdelivr.net/npm/materialize-css@1.0.0/dist/js/materialize.min.js"></script>
    <script>
        // API SETTINGS
        const apiBase = "https://localhost:7188/api/customers";
        const apiKey = "MySecretKey123";

        function toggleDark() {
            document.body.classList.toggle('darkmode');
            document.documentElement.classList.toggle('darkmode');
            document.getElementById('rootContainer').classList.toggle('darkmode');
        }
        function avatarFor(name) {
            let ch = (name && name.trim()) ? name.trim()[0].toUpperCase() : "?";
            const colors = ["#1976d2", "#ff7043", "#388e3c", "#e64a19", "#00897b", "#7c43bd", "#c2185b"];
            let idx = ch.charCodeAt(0) % colors.length;
            return `<span class="avatar" style="background:${colors[idx]};">${ch}</span>`;
        }
        function showMsg(msg, good = false) {
            const el = document.getElementById('msg');
            el.textContent = msg || '';
            el.className = "msg " + (good ? "success green-text" : "red-text");
        }
        function clearMsg() { showMsg(''); }
        function setLoading(val) { document.getElementById('loading').style.display = val ? "" : "none"; }
        function showResults(list) {
            setLoading(false);
            const table = document.getElementById('resultTable');
            const tbody = document.getElementById('resultBody');
            tbody.innerHTML = '';
            if (!list || list.length === 0) {
                table.style.display = 'none';
                showMsg('No customers found.');
                return;
            }
            table.style.display = '';
            for (let c of list) {
                let row = document.createElement('tr');
                row.innerHTML = `<td>${avatarFor(c.name)}</td>
                  <td>${c.name}</td>
                  <td>${c.mobile}</td>
                  <td>${c.createdAt ? c.createdAt.replace('T', ' ').substring(0, 19) : ''}</td>
                  <td class="center-actions center-align">
                    <button class="btn-small waves-effect red lighten-1 tooltipped" data-tooltip="Delete"
                    onclick="del('${c.mobile}')"><i class="material-icons">delete</i></button>
                  </td>`;
                tbody.appendChild(row);
            }
            M.Tooltip.init(document.querySelectorAll('.tooltipped'));
            clearMsg();
        }

        function fetchAndShow(url) {
            setLoading(true);
            fetch(url)
                .then(r => { setLoading(false); if (!r.ok) throw r; return r.json(); })
                .then(showResults)
                .catch(async err => {
                    setLoading(false);
                    let msg = "Failed to fetch.";
                    if (err.json) {
                        let j = await err.json().catch(() => null);
                        if (j && j.message) msg = j.message;
                    }
                    showMsg(msg, false);
                    M.toast({ html: msg, classes: 'red' });
                });
        }

        function search() {
            let term = document.getElementById('searchBox').value.trim();
            if (!term) { showMsg("Enter a name to search."); return; }
            fetchAndShow(`${apiBase}/search?name=${encodeURIComponent(term)}`);
        }

        function getAll() { fetchAndShow(apiBase); }

        function addCustomer() {
            clearMsg();
            let name = document.getElementById('inputName').value.trim();
            let mobile = document.getElementById('inputMobile').value.trim();
            if (!name || !mobile) { showMsg("Name and mobile are required."); return; }
            setLoading(true);
            fetch(apiBase, {
                method: "POST",
                headers: { "Content-Type": "application/json", "X-API-KEY": apiKey },
                body: JSON.stringify({ name, mobile })
            })
                .then(r => { setLoading(false); if (r.ok) return r.json(); return r.json().then(e => { throw e; }); })
                .then(d => {
                    showMsg("Customer added!", true);
                    M.toast({ html: "Customer added!", classes: 'green darken-2' });
                    getAll();
                    document.getElementById('addForm').reset();
                })
                .catch(async err => {
                    setLoading(false);
                    let msg = err.message || "Failed to add.";
                    if (err.errors) {
                        for (const prop in err.errors) {
                            msg += ` ${prop}: ${err.errors[prop].join(',')}`;
                        }
                    }
                    if (err.json) {
                        let j = await err.json().catch(() => null);
                        if (j && j.message) msg = j.message;
                    }
                    showMsg(msg, false);
                    M.toast({ html: msg, classes: 'red' });
                });
        }

        function del(mobile) {
            if (!confirm("Are you sure you want to delete this customer?")) return;
            setLoading(true);
            fetch(`${apiBase}/${encodeURIComponent(mobile)}`, {
                method: "DELETE",
                headers: { "X-API-KEY": apiKey }
            })
                .then(r => { setLoading(false); if (!r.ok) throw r; showMsg("Deleted!", true); M.toast({ html: "Customer deleted!", classes: 'green darken-2' }); getAll(); })
                .catch(async err => {
                    setLoading(false);
                    let msg = "Failed to delete.";
                    if (err.json) {
                        let j = await err.json().catch(() => null);
                        if (j && j.message) msg = j.message;
                    }
                    showMsg(msg, false); M.toast({ html: msg, classes: 'red' });
                });
        }

        // ===== DIAMOND AND LINES PATTERN EFFECT =====
        function getRandomDiamondColor(alpha = 0.8, mode = 'light') {
            let palette = mode === 'dark'
                ? [[52, 61, 82], [70, 61, 121], [29, 180, 162], [138, 43, 226], [13, 99, 158], [71, 125, 207], [48, 202, 202], [120, 172, 233], [169, 104, 205], [56, 201, 162]]
                : [[240, 236, 202], [210, 77, 87], [106, 17, 203], [18, 194, 233], [37, 117, 252], [252, 227, 138], [141, 153, 174], [55, 175, 240], [236, 159, 159], [255, 214, 102]];
            let idx = Math.floor(Math.random() * palette.length);
            let c = palette[idx];
            return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
        }
        // Returns a CSS background-image with diamonds and diagonal lines pattern, with randomized colors/positions
        function diamondLinesPattern(mode) {
            // Diamond pattern via repeating-linear-gradient and repeating-conic-gradient
            let fg = getRandomDiamondColor(0.24, mode),
                fg2 = getRandomDiamondColor(0.33, mode),
                diamond = `repeating-linear-gradient(135deg, transparent 0 32px, ${fg} 32px 38px, transparent 38px 80px)`,
                diamond2 = `repeating-linear-gradient(225deg, transparent 0 32px, ${fg2} 32px 38px, transparent 38px 80px)`;
            // Diagonal lines on top
            let lineCol = getRandomDiamondColor(0.17, mode),
                lines = `repeating-linear-gradient(45deg, transparent 0 14px, ${lineCol} 14px 16px, transparent 16px 30px)`;
            // Diamonds via conic gradient mask
            let diamondMask = `repeating-conic-gradient(from 0deg, ${getRandomDiamondColor(0.19, mode)} 0 15deg, transparent 15deg 30deg)`;
            // Overlay all with soft white/dark base
            let base = (mode === 'dark') ? 'rgba(21,24,32,0.97)' : 'rgba(255,255,255,0.99)';
            return `${diamond},${diamond2},${lines},${diamondMask},${base}`;
        }

        function enablePatternEffect() {
            const cont = document.getElementById("rootContainer");
            let currMode = () => document.body.classList.contains('darkmode') ? 'dark' : 'light';
            function setPatternBg() {
                cont.classList.add('patterned-bg');
                cont.style.backgroundImage = diamondLinesPattern(currMode());
            }
            function clearPatternBg() {
                cont.classList.remove('patterned-bg');
                cont.style.backgroundImage = "";
            }
            // Interactions:
            cont.addEventListener("mouseenter", setPatternBg);
            cont.addEventListener("mousedown", setPatternBg);
            cont.addEventListener("mouseup", clearPatternBg);
            cont.addEventListener("mouseleave", clearPatternBg);
            cont.addEventListener('mousemove', function () {
                if (cont.classList.contains('patterned-bg')) {
                    // Subtle refresh as you move for sparkle
                    if (Math.random() > 0.86) setPatternBg();
                }
            });
            // On dark mode toggle, always clear
            document.getElementById('darkToggle').addEventListener('change', clearPatternBg);
        }

        document.addEventListener("DOMContentLoaded", function () {
            M.AutoInit();
            enablePatternEffect();
            getAll();
        });

    </script>

</body>
<!-- Memphis Retro Overlay Pattern FX (Full Screen, smooth, always behind card) -->
<script>
document.addEventListener("DOMContentLoaded", function () {
    // --- add overlay EARLY in <body> so it's under the card ---
    let overlay = document.createElement('canvas');
    overlay.id = "retroOverlayFX";
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.pointerEvents = "none";
    overlay.style.zIndex = "0"; // LOWER than .container (z-index: 1)
    overlay.style.transition = "opacity .44s cubic-bezier(.4,.8,.43,1.03)";
    overlay.style.opacity = "0";
    document.body.insertBefore(overlay, document.body.firstChild);
    overlay.width = window.innerWidth;
    overlay.height = window.innerHeight;

    function isDark() {
        return document.body.classList.contains('darkmode');
    }

    let ctx = overlay.getContext('2d');
    let drawInterval = null;
    function makeRetroColor(mode) {
        if (Math.random() < 0.55)
            return mode === "dark" ? "#fff" : "#000";
        let pastel = [
            "#2dfaec","#ffe233","#ff3b57","#25a7fa","#adff2d","#faa727","#feffb1","#a23dff",
            "#ff6ec7","#44f16c","#fff","#212132"
        ];
        let c = pastel[Math.floor(Math.random() * pastel.length)];
        if (mode==="dark" && Math.random()>0.55) c="#fff";
        return c;
    }
    function drawRetroPattern() {
        let mode = isDark() ? "dark" : "light";
        let w = overlay.width = window.innerWidth, h = overlay.height = window.innerHeight;
        ctx.clearRect(0,0,w,h);
        let count = Math.floor(w*h/7500 * 2.6);
        for (let i=0; i<count; ++i) {
            let x = Math.random()*w, y = Math.random()*h;
            let t = Math.random();
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2);
            if (t < 0.15) { // squiggle
                let c = makeRetroColor(mode);
                ctx.strokeStyle = c;
                ctx.lineWidth = 1.5 + Math.random()*1.6;
                ctx.beginPath();
                let len = 14 + Math.random()*16;
                for (let j=0;j<7;++j) {
                    ctx.lineTo(j*len/7, Math.sin(j/1.17+Math.random()*1.2)*6);
                }
                ctx.stroke();
            } else if (t < 0.28) { // triangle
                ctx.fillStyle = makeRetroColor(mode);
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(10 + Math.random()*9, -8-Math.random()*4);
                ctx.lineTo(-7-Math.random()*5, 13+Math.random()*4);
                ctx.closePath();
                ctx.globalAlpha = 0.66 + Math.random()*0.22;
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (t < 0.42) { // hollow circle
                ctx.strokeStyle = makeRetroColor(mode);
                ctx.lineWidth = 1.1 + Math.random()*1.0;
                ctx.beginPath();
                ctx.arc(0,0,4+Math.random()*10,0,2*Math.PI);
                ctx.stroke();
            } else if (t < 0.52) { // X
                ctx.strokeStyle = makeRetroColor(mode);
                ctx.lineWidth = 1.8 + Math.random();
                let r = 5+Math.random()*8;
                ctx.beginPath();
                ctx.moveTo(-r,-r);
                ctx.lineTo(r,r);
                ctx.moveTo(-r,r);
                ctx.lineTo(r,-r);
                ctx.stroke();
            } else if (t < 0.76) { // dots
                ctx.fillStyle = makeRetroColor(mode);
                ctx.globalAlpha = 0.32 + Math.random()*0.45;
                ctx.beginPath();
                ctx.arc(0,0,1.1+Math.random()*2.2,0,2*Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else { // mini arc
                ctx.strokeStyle = makeRetroColor(mode);
                ctx.lineWidth = 0.7+Math.random()*1.2;
                ctx.beginPath();
                ctx.arc(0,0,4+Math.random()*9,Math.PI*0.1,Math.PI*1.1);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    function showOverlay() {
        overlay.width = window.innerWidth;
        overlay.height = window.innerHeight;
        drawRetroPattern();
        overlay.style.opacity = "1";
        if (drawInterval) clearInterval(drawInterval);
        drawInterval = setInterval(drawRetroPattern, 1200 + Math.random()*700);
    }
    function hideOverlay() {
        overlay.style.opacity = "0";
        if (drawInterval) clearInterval(drawInterval);
    }
    document.body.addEventListener('mousemove', function (e) {
        let el = e.target, onCard = false;
        while (el) {
            if (el.classList && el.classList.contains('container')) { onCard = true; break; }
            el = el.parentElement;
        }
        if (!onCard) showOverlay();
        else hideOverlay();
    });
    document.body.addEventListener('mousedown', showOverlay);
    document.body.addEventListener('mouseleave', hideOverlay);
    document.body.addEventListener('mouseup', hideOverlay);
    window.addEventListener('resize', function () {
        overlay.width = window.innerWidth;
        overlay.height = window.innerHeight;
        if (overlay.style.opacity === "1") drawRetroPattern();
    });
    document.getElementById('darkToggle').addEventListener('change', hideOverlay);
    document.body.addEventListener('focusin', hideOverlay);
    // --- Touch support for mobile/tablet ---
    // Show doodles on background touch
    document.body.addEventListener('touchstart', function (e) {
        let el = e.target, onCard = false;
        while (el) {
            if (el.classList && el.classList.contains('container')) { onCard = true; break; }
            el = el.parentElement;
        }
        if (!onCard) showOverlay();
        else hideOverlay();
    }, { passive: true });

    // Hide doodles when touch ends or cancels
    document.body.addEventListener('touchend', hideOverlay, { passive: true });
    document.body.addEventListener('touchcancel', hideOverlay, { passive: true });

    hideOverlay();
});
</script>

</html>
